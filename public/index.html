<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Voice Bridge - Llamada de Voz</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: #0f0f1a;
    color: #fff;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .container {
    width: 100%;
    max-width: 420px;
    padding: 20px;
    text-align: center;
  }
  h1 { font-size: 1.4rem; margin-bottom: 6px; color: #a78bfa; }
  .subtitle { font-size: 0.85rem; color: #666; margin-bottom: 30px; }

  /* Status */
  .status {
    font-size: 0.85rem;
    padding: 8px 16px;
    border-radius: 20px;
    display: inline-block;
    margin-bottom: 30px;
  }
  .status.idle { background: #1a1a2e; color: #888; }
  .status.connecting { background: #1a1a2e; color: #f59e0b; }
  .status.ready { background: #0d2818; color: #4ade80; }
  .status.recording { background: #2d1215; color: #f87171; animation: pulse 1s infinite; }
  .status.thinking { background: #1a1a2e; color: #a78bfa; animation: pulse 1.5s infinite; }
  .status.speaking { background: #0d2818; color: #4ade80; }
  .status.error { background: #2d1215; color: #f87171; }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  /* Mic button */
  .mic-area { margin: 20px 0 30px; }
  .mic-btn {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 3px solid #333;
    background: #1a1a2e;
    color: #888;
    font-size: 48px;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto;
    user-select: none;
    -webkit-user-select: none;
  }
  .mic-btn:hover { border-color: #a78bfa; color: #a78bfa; }
  .mic-btn.recording {
    border-color: #f87171;
    background: #2d1215;
    color: #f87171;
    box-shadow: 0 0 30px rgba(248,113,113,0.3);
    animation: pulse-btn 1s infinite;
  }
  .mic-btn.disabled { opacity: 0.4; cursor: not-allowed; }

  @keyframes pulse-btn {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
  }

  .mic-hint {
    font-size: 0.8rem;
    color: #555;
    margin-top: 12px;
  }

  /* Chat / text input */
  .text-area {
    display: flex;
    gap: 8px;
    margin-bottom: 20px;
  }
  .text-area input {
    flex: 1;
    padding: 10px 14px;
    border-radius: 10px;
    border: 1px solid #333;
    background: #1a1a2e;
    color: #fff;
    font-size: 0.9rem;
    outline: none;
  }
  .text-area input:focus { border-color: #a78bfa; }
  .text-area button {
    padding: 10px 18px;
    border-radius: 10px;
    border: none;
    background: #a78bfa;
    color: #fff;
    font-size: 0.9rem;
    cursor: pointer;
  }
  .text-area button:hover { background: #8b5cf6; }

  /* Messages */
  .messages {
    max-height: 300px;
    overflow-y: auto;
    margin-bottom: 20px;
    text-align: left;
  }
  .msg {
    padding: 10px 14px;
    border-radius: 12px;
    margin-bottom: 8px;
    font-size: 0.85rem;
    line-height: 1.4;
    max-width: 90%;
  }
  .msg.user {
    background: #2d1b69;
    color: #c4b5fd;
    margin-left: auto;
    text-align: right;
  }
  .msg.assistant {
    background: #1a2e1a;
    color: #a7f3d0;
  }
  .msg .time {
    font-size: 0.7rem;
    color: #555;
    margin-top: 4px;
  }

  /* Config */
  .config {
    background: #1a1a2e;
    border-radius: 12px;
    padding: 14px;
    margin-bottom: 20px;
    text-align: left;
  }
  .config summary {
    cursor: pointer;
    font-size: 0.85rem;
    color: #888;
  }
  .config-inner { margin-top: 12px; }
  .config label {
    display: block;
    font-size: 0.75rem;
    color: #666;
    margin-bottom: 3px;
    margin-top: 8px;
  }
  .config input, .config select {
    width: 100%;
    padding: 8px;
    border-radius: 8px;
    border: 1px solid #333;
    background: #0f0f1a;
    color: #fff;
    font-size: 0.8rem;
  }
  .config .connect-btn {
    width: 100%;
    padding: 10px;
    border-radius: 8px;
    border: none;
    background: #4ade80;
    color: #000;
    font-weight: 600;
    cursor: pointer;
    margin-top: 12px;
    font-size: 0.85rem;
  }
  .config .connect-btn:hover { background: #22c55e; }
  .config .connect-btn.disconnect { background: #f87171; color: #fff; }
</style>
</head>
<body>
<div class="container">
  <h1>Voice Bridge</h1>
  <p class="subtitle">Habla con la IA por voz o texto</p>

  <!-- Config -->
  <details class="config" id="configPanel">
    <summary>Configuracion</summary>
    <div class="config-inner">
      <label>URL del Bridge</label>
      <input type="text" id="bridgeUrl" value="https://host-voice-real-time.pijpe2.easypanel.host">
      <label>Token de autenticacion</label>
      <input type="password" id="bridgeToken" value="vrb_s3cur3_t0k3n_2024x">
      <label>Instrucciones del asistente</label>
      <input type="text" id="instructions" value="Eres un asistente amable. Responde siempre en espanol de forma natural y concisa.">
      <label>Voz</label>
      <select id="voiceSelect">
        <option value="alloy" selected>Alloy</option>
        <option value="echo">Echo</option>
        <option value="fable">Fable</option>
        <option value="onyx">Onyx</option>
        <option value="nova">Nova</option>
        <option value="shimmer">Shimmer</option>
        <option value="coral">Coral</option>
        <option value="verse">Verse</option>
      </select>
      <button class="connect-btn" id="connectBtn" onclick="toggleSession()">Iniciar Sesion</button>
    </div>
  </details>

  <!-- Status -->
  <div class="status idle" id="status">Sin conexion</div>

  <!-- Messages -->
  <div class="messages" id="messages"></div>

  <!-- Mic -->
  <div class="mic-area">
    <button class="mic-btn disabled" id="micBtn">&#127908;</button>
    <div class="mic-hint" id="micHint">Conecta primero para hablar</div>
  </div>

  <!-- Text input -->
  <div class="text-area">
    <input type="text" id="textInput" placeholder="O escribe un mensaje..." disabled>
    <button id="sendBtn" onclick="sendText()" disabled>Enviar</button>
  </div>
</div>

<script>
let sessionId = null;
let mediaRecorder = null;
let audioChunks = [];
let isRecording = false;
let audioContext = null;

const $ = id => document.getElementById(id);
const statusEl = $('status');
const micBtn = $('micBtn');
const micHint = $('micHint');
const messagesEl = $('messages');
const textInput = $('textInput');
const sendBtn = $('sendBtn');
const connectBtn = $('connectBtn');

function getConfig() {
  return {
    url: $('bridgeUrl').value.replace(/\/$/, ''),
    token: $('bridgeToken').value,
    instructions: $('instructions').value,
    voice: $('voiceSelect').value,
  };
}

function setStatus(text, cls) {
  statusEl.textContent = text;
  statusEl.className = 'status ' + cls;
}

function addMessage(text, role, durationMs) {
  const div = document.createElement('div');
  div.className = 'msg ' + role;
  div.innerHTML = text + (durationMs ? `<div class="time">${durationMs}ms</div>` : '');
  messagesEl.appendChild(div);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

async function apiFetch(path, body) {
  const cfg = getConfig();
  const res = await fetch(cfg.url + path, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer ' + cfg.token,
    },
    body: JSON.stringify(body),
  });
  return res.json();
}

// --- Session ---
async function toggleSession() {
  if (sessionId) {
    await endSession();
  } else {
    await startSession();
  }
}

async function startSession() {
  const cfg = getConfig();
  setStatus('Conectando...', 'connecting');
  connectBtn.textContent = 'Conectando...';

  try {
    const data = await apiFetch('/api/v1/sessions', {
      instructions: cfg.instructions,
      voice: cfg.voice,
    });

    if (!data.success) throw new Error(data.error);

    sessionId = data.session_id;
    setStatus('Conectado - Listo para hablar', 'ready');
    connectBtn.textContent = 'Desconectar';
    connectBtn.classList.add('disconnect');
    micBtn.classList.remove('disabled');
    micHint.textContent = 'Manten presionado para hablar';
    textInput.disabled = false;
    sendBtn.disabled = false;
    $('configPanel').open = false;
  } catch (err) {
    setStatus('Error: ' + err.message, 'error');
    connectBtn.textContent = 'Iniciar Sesion';
  }
}

async function endSession() {
  if (sessionId) {
    const cfg = getConfig();
    try {
      await fetch(cfg.url + '/api/v1/sessions/' + sessionId, {
        method: 'DELETE',
        headers: { 'Authorization': 'Bearer ' + cfg.token },
      });
    } catch(e) {}
  }
  sessionId = null;
  setStatus('Sin conexion', 'idle');
  connectBtn.textContent = 'Iniciar Sesion';
  connectBtn.classList.remove('disconnect');
  micBtn.classList.add('disabled');
  micHint.textContent = 'Conecta primero para hablar';
  textInput.disabled = true;
  sendBtn.disabled = true;
}

// --- Text ---
async function sendText() {
  const msg = textInput.value.trim();
  if (!msg || !sessionId) return;

  textInput.value = '';
  addMessage(msg, 'user');
  setStatus('Pensando...', 'thinking');

  try {
    const data = await apiFetch('/api/v1/sessions/' + sessionId + '/text', {
      message: msg,
      return_audio: true,
    });

    if (!data.success) throw new Error(data.error);

    setStatus('Reproduciendo respuesta...', 'speaking');
    addMessage(data.response_text, 'assistant', data.duration_ms);

    if (data.audio_wav_base64) {
      await playAudioBase64(data.audio_wav_base64);
    }

    setStatus('Conectado - Listo para hablar', 'ready');
  } catch(err) {
    setStatus('Error: ' + err.message, 'error');
    setTimeout(() => {
      if (sessionId) setStatus('Conectado - Listo para hablar', 'ready');
    }, 3000);
  }
}

textInput.addEventListener('keydown', e => {
  if (e.key === 'Enter') sendText();
});

// --- Audio recording ---
micBtn.addEventListener('mousedown', startRecording);
micBtn.addEventListener('mouseup', stopRecording);
micBtn.addEventListener('mouseleave', stopRecording);
micBtn.addEventListener('touchstart', e => { e.preventDefault(); startRecording(); });
micBtn.addEventListener('touchend', e => { e.preventDefault(); stopRecording(); });

async function startRecording() {
  if (!sessionId || isRecording) return;
  isRecording = true;
  audioChunks = [];
  micBtn.classList.add('recording');
  setStatus('Grabando... suelta para enviar', 'recording');

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });

    mediaRecorder.ondataavailable = e => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      stream.getTracks().forEach(t => t.stop());
      if (audioChunks.length === 0) return;

      const blob = new Blob(audioChunks, { type: 'audio/webm' });
      await sendAudioBlob(blob);
    };

    mediaRecorder.start(100);
  } catch(err) {
    isRecording = false;
    micBtn.classList.remove('recording');
    setStatus('Error microfono: ' + err.message, 'error');
  }
}

function stopRecording() {
  if (!isRecording || !mediaRecorder) return;
  isRecording = false;
  micBtn.classList.remove('recording');

  if (mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
  }
}

async function sendAudioBlob(webmBlob) {
  setStatus('Procesando audio...', 'thinking');
  addMessage('[Audio enviado]', 'user');

  try {
    // Convert webm to WAV PCM16 using AudioContext
    const arrayBuffer = await webmBlob.arrayBuffer();

    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
    }

    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    const wavBase64 = audioBufferToWavBase64(audioBuffer);

    setStatus('Esperando respuesta...', 'thinking');

    const data = await apiFetch('/api/v1/sessions/' + sessionId + '/audio', {
      audio_base64: wavBase64,
      audio_format: 'wav',
      return_audio: true,
    });

    if (!data.success) throw new Error(data.error);

    if (data.input_transcript) {
      // Update last user message with transcript
      const msgs = messagesEl.querySelectorAll('.msg.user');
      if (msgs.length > 0) {
        msgs[msgs.length - 1].innerHTML = data.input_transcript;
      }
    }

    setStatus('Reproduciendo respuesta...', 'speaking');
    addMessage(data.response_text, 'assistant', data.duration_ms);

    if (data.audio_wav_base64) {
      await playAudioBase64(data.audio_wav_base64);
    }

    setStatus('Conectado - Listo para hablar', 'ready');
  } catch(err) {
    setStatus('Error: ' + err.message, 'error');
    setTimeout(() => {
      if (sessionId) setStatus('Conectado - Listo para hablar', 'ready');
    }, 3000);
  }
}

// --- Audio playback ---
function playAudioBase64(wavBase64) {
  return new Promise((resolve) => {
    const audio = new Audio('data:audio/wav;base64,' + wavBase64);
    audio.onended = resolve;
    audio.onerror = resolve;
    audio.play().catch(resolve);
  });
}

// --- WAV encoder ---
function audioBufferToWavBase64(buffer) {
  const numChannels = 1;
  const sampleRate = 24000;
  const format = 1; // PCM

  // Resample to 24kHz mono
  const inputData = buffer.getChannelData(0);
  const inputSampleRate = buffer.sampleRate;
  const ratio = inputSampleRate / sampleRate;
  const outputLength = Math.floor(inputData.length / ratio);
  const outputData = new Float32Array(outputLength);

  for (let i = 0; i < outputLength; i++) {
    const srcIndex = i * ratio;
    const srcIndexFloor = Math.floor(srcIndex);
    const frac = srcIndex - srcIndexFloor;
    const s0 = inputData[srcIndexFloor] || 0;
    const s1 = inputData[srcIndexFloor + 1] || 0;
    outputData[i] = s0 + (s1 - s0) * frac;
  }

  // Convert to 16-bit PCM
  const pcm16 = new Int16Array(outputLength);
  for (let i = 0; i < outputLength; i++) {
    const s = Math.max(-1, Math.min(1, outputData[i]));
    pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
  }

  // Build WAV
  const byteRate = sampleRate * numChannels * 2;
  const blockAlign = numChannels * 2;
  const dataSize = pcm16.length * 2;
  const wavBuffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(wavBuffer);

  const writeString = (offset, str) => {
    for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
  };

  writeString(0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true);
  writeString(8, 'WAVE');
  writeString(12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, format, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, 16, true);
  writeString(36, 'data');
  view.setUint32(40, dataSize, true);

  const pcmBytes = new Uint8Array(wavBuffer, 44);
  const pcm16Bytes = new Uint8Array(pcm16.buffer);
  pcmBytes.set(pcm16Bytes);

  // To base64
  let binary = '';
  const bytes = new Uint8Array(wavBuffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// Auto-connect on page load if URL params present
const params = new URLSearchParams(window.location.search);
if (params.get('autoconnect') === '1') {
  window.addEventListener('load', () => startSession());
}
</script>
</body>
</html>
