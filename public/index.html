<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Voice Bridge - Llamada</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0a0a12;
      color: #fff;
      min-height: 100vh;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .container {
      width: 100%;
      max-width: 400px;
      padding: 20px;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      height: 100dvh;
      justify-content: space-between;
      padding-top: 40px;
      padding-bottom: 40px;
    }

    /* Top */
    .top {
      width: 100%;
    }

    .call-label {
      font-size: 0.75rem;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 8px;
    }

    .assistant-name {
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .call-timer {
      font-size: 0.85rem;
      color: #666;
      font-variant-numeric: tabular-nums;
    }

    /* Middle */
    .middle {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      gap: 12px;
    }

    /* Visualizer */
    .visualizer {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle, #1a1a3e 0%, #0a0a12 70%);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .visualizer::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 2px solid #222;
      transition: all 0.3s;
    }

    .visualizer.listening::before {
      border-color: #4ade80;
      box-shadow: 0 0 30px rgba(74, 222, 128, .15);
    }

    .visualizer.user-speaking::before {
      border-color: #a78bfa;
      box-shadow: 0 0 40px rgba(167, 139, 250, .3);
      animation: ring-pulse .8s ease-in-out infinite;
    }

    .visualizer.thinking::before {
      border-color: #f59e0b;
      animation: ring-spin 2s linear infinite;
    }

    .visualizer.ai-speaking::before {
      border-color: #4ade80;
      box-shadow: 0 0 50px rgba(74, 222, 128, .3);
      animation: ring-pulse 1.2s ease-in-out infinite;
    }

    @keyframes ring-pulse {

      0%,
      100% {
        transform: scale(1);
        opacity: 1
      }

      50% {
        transform: scale(1.08);
        opacity: .7
      }
    }

    @keyframes ring-spin {
      0% {
        transform: rotate(0deg);
        border-style: dashed
      }

      100% {
        transform: rotate(360deg);
        border-style: dashed
      }
    }

    .bars {
      display: flex;
      align-items: center;
      gap: 4px;
      height: 60px;
    }

    .bar {
      width: 5px;
      background: #333;
      border-radius: 3px;
      transition: height .1s, background .3s;
      height: 8px;
    }

    .visualizer.listening .bar {
      background: #4ade8055;
    }

    .visualizer.user-speaking .bar {
      background: #a78bfa;
    }

    .visualizer.thinking .bar {
      background: #f59e0b55;
      height: 8px !important;
    }

    .visualizer.ai-speaking .bar {
      background: #4ade80;
    }

    .status-text {
      font-size: .85rem;
      color: #666;
      min-height: 20px;
    }

    .status-text.active {
      color: #4ade80;
    }

    .status-text.speaking {
      color: #a78bfa;
    }

    .status-text.waiting {
      color: #f59e0b;
    }

    /* Transcript */
    .transcript {
      width: 100%;
      max-height: 110px;
      overflow-y: auto;
      padding: 0 10px;
    }

    .transcript p {
      font-size: .8rem;
      line-height: 1.4;
      margin-bottom: 6px;
      padding: 6px 10px;
      border-radius: 8px;
    }

    .transcript .user-text {
      color: #c4b5fd;
      background: #1a1535;
      text-align: right;
    }

    .transcript .ai-text {
      color: #a7f3d0;
      background: #0d1f0d;
    }

    /* Logs */
    .logs-panel {
      width: 100%;
      max-height: 80px;
      overflow-y: auto;
      background: #0d0d14;
      border: 1px solid #222;
      border-radius: 8px;
      padding: 8px;
      font-size: .68rem;
      font-family: monospace;
      text-align: left;
      color: #888;
    }

    .logs-panel .log-error {
      color: #f87171;
    }

    .logs-panel .log-info {
      color: #60a5fa;
    }

    .logs-panel .log-success {
      color: #4ade80;
    }

    /* Bottom */
    .bottom {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .call-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 24px;
      width: 100%;
    }

    .call-btn {
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: all .3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .call-btn.end-btn {
      width: 64px;
      height: 64px;
      font-size: 26px;
      background: #ef4444;
      color: #fff;
      box-shadow: 0 0 20px rgba(239, 68, 68, .3);
    }

    .call-btn.end-btn:hover {
      background: #dc2626;
      transform: scale(1.05);
    }

    .call-btn.start-btn {
      width: 72px;
      height: 72px;
      font-size: 28px;
      background: #22c55e;
      color: #fff;
      box-shadow: 0 0 20px rgba(34, 197, 94, .3);
    }

    .call-btn.start-btn:hover {
      background: #16a34a;
      transform: scale(1.05);
    }

    /* PTT button */
    .ptt-btn {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      border: none;
      font-size: 38px;
      cursor: pointer;
      background: #3b82f6;
      color: #fff;
      box-shadow: 0 0 24px rgba(59, 130, 246, .4);
      transition: all .15s;
      display: none;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    .ptt-btn.active {
      background: #a78bfa;
      box-shadow: 0 0 40px rgba(167, 139, 250, .6);
      transform: scale(.95);
    }

    .ptt-hint {
      font-size: .75rem;
      color: #666;
      display: none;
    }

    .call-btn-label {
      font-size: .75rem;
      color: #666;
    }

    /* Settings */
    .settings-btn {
      position: fixed;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      color: #444;
      font-size: 20px;
      cursor: pointer;
      z-index: 10;
    }

    .settings-btn:hover {
      color: #888;
    }

    .modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, .7);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal {
      background: #151520;
      border-radius: 16px;
      padding: 24px;
      width: 90%;
      max-width: 380px;
      border: 1px solid #222;
    }

    .modal h2 {
      font-size: 1rem;
      margin-bottom: 16px;
      color: #aaa;
    }

    .modal label {
      display: block;
      font-size: .75rem;
      color: #555;
      margin-bottom: 4px;
      margin-top: 12px;
    }

    .modal input,
    .modal select {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #333;
      background: #0a0a12;
      color: #fff;
      font-size: .85rem;
    }

    .modal textarea {
      width: 100%;
      padding: 10px;
      border-radius: 8px;
      border: 1px solid #333;
      background: #0a0a12;
      color: #fff;
      font-size: .85rem;
      resize: vertical;
      min-height: 60px;
    }

    .modal .save-btn {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: none;
      background: #a78bfa;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      margin-top: 16px;
      font-size: .9rem;
    }

    .modal .save-btn:hover {
      background: #8b5cf6;
    }
  </style>
</head>

<body>

  <button class="settings-btn" onclick="toggleSettings()">&#9881;</button>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <h2>Configuración</h2>
      <label>URL del Bridge</label>
      <input type="text" id="bridgeUrl" value="https://host-voice-real-time.pijpe2.easypanel.host">
      <label>Token</label>
      <input type="password" id="bridgeToken" value="vrb_s3cur3_t0k3n_2024x">
      <label>Instrucciones</label>
      <textarea
        id="instructions">Eres un asistente de voz amable y conversacional. Responde siempre en español de forma natural, concisa y con un tono humano. Tus respuestas deben ser cortas y directas, como en una llamada telefonica real.</textarea>
      <label>Voz</label>
      <select id="voiceSelect">
        <option value="alloy">Alloy</option>
        <option value="coral">Coral</option>
        <option value="echo">Echo</option>
        <option value="fable">Fable</option>
        <option value="nova">Nova</option>
        <option value="onyx">Onyx</option>
        <option value="shimmer">Shimmer</option>
        <option value="sol" selected>Sol</option>
        <option value="verse">Verse</option>
      </select>
      <button class="save-btn" onclick="toggleSettings()">Guardar</button>
    </div>
  </div>

  <div class="container">
    <!-- Top -->
    <div class="top">
      <div class="call-label">Llamada de voz</div>
      <div class="assistant-name">Asistente IA</div>
      <div class="call-timer" id="timer">--:--</div>
    </div>

    <!-- Middle -->
    <div class="middle">
      <div class="visualizer" id="visualizer">
        <div class="bars" id="bars"></div>
      </div>
      <div class="status-text" id="statusText">Toca para llamar</div>
      <div class="transcript" id="transcript"></div>
      <div class="logs-panel" id="logsPanel"></div>
    </div>

    <!-- Bottom -->
    <div class="bottom">
      <!-- PTT (visible durante llamada) -->
      <button class="ptt-btn" id="pttBtn" onmousedown="startPTT()" onmouseup="stopPTT()" onmouseleave="stopPTT()"
        ontouchstart="startPTT(); event.preventDefault();" ontouchend="stopPTT(); event.preventDefault();">
        &#127897;
      </button>
      <div class="ptt-hint" id="pttHint">Mantén presionado para hablar</div>

      <!-- Call controls -->
      <div class="call-row">
        <button class="call-btn start-btn" id="callBtn" onclick="toggleCall()" style="display:flex;">&#128222;</button>
        <button class="call-btn end-btn" id="hangBtn" onclick="endCall()" style="display:none;">&#128405;</button>
      </div>
      <div class="call-btn-label" id="callLabel">Llamar</div>
    </div>
  </div>

  <script>
    // --- State ---
    let sessionId = null;
    let inCall = false;
    let stream = null;
    let audioContext = null;
    let analyser = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let isSpeaking = false;
    let isProcessing = false;
    let callStartTime = null;
    let timerInterval = null;
    let currentAudio = null;
    let speechStartTime = null;

    const MIN_SPEECH_MS = 400;
    const NUM_BARS = 12;

    // --- DOM ---
    const $ = id => document.getElementById(id);
    const visualizer = $('visualizer');
    const barsEl = $('bars');
    const statusText = $('statusText');
    const callBtn = $('callBtn');
    const hangBtn = $('hangBtn');
    const callLabel = $('callLabel');
    const pttBtn = $('pttBtn');
    const pttHint = $('pttHint');
    const timerEl = $('timer');
    const transcriptEl = $('transcript');
    const logsPanel = $('logsPanel');

    // --- Bars ---
    for (let i = 0; i < NUM_BARS; i++) {
      const b = document.createElement('div');
      b.className = 'bar';
      barsEl.appendChild(b);
    }
    const bars = barsEl.querySelectorAll('.bar');

    // --- Logger ---
    function addLog(msg, type = 'info') {
      console.log(`[${type.toUpperCase()}] ${msg}`);
      const d = new Date();
      const t = `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}:${String(d.getSeconds()).padStart(2, '0')}`;
      const el = document.createElement('div');
      el.className = `log-${type}`;
      el.textContent = `[${t}] ${msg}`;
      logsPanel.appendChild(el);
      logsPanel.scrollTop = logsPanel.scrollHeight;
    }

    // --- Config ---
    function getConfig() {
      return {
        url: $('bridgeUrl').value.replace(/\/$/, ''),
        token: $('bridgeToken').value,
        instructions: $('instructions').value,
        voice: $('voiceSelect').value,
      };
    }

    function toggleSettings() {
      $('settingsModal').classList.toggle('open');
    }

    // --- UI States ---
    function setUI(state) {
      visualizer.className = 'visualizer';
      switch (state) {
        case 'idle':
          callBtn.style.display = 'flex';
          hangBtn.style.display = 'none';
          pttBtn.style.display = 'none';
          pttHint.style.display = 'none';
          pttBtn.classList.remove('active');
          callLabel.textContent = 'Llamar';
          statusText.textContent = 'Toca para llamar';
          statusText.className = 'status-text';
          timerEl.textContent = '--:--';
          bars.forEach(b => b.style.height = '8px');
          break;
        case 'connecting':
          callBtn.style.display = 'none';
          hangBtn.style.display = 'flex';
          pttBtn.style.display = 'none';
          pttHint.style.display = 'none';
          callLabel.textContent = 'Conectando...';
          statusText.textContent = 'Conectando...';
          statusText.className = 'status-text waiting';
          break;
        case 'listening':
          callBtn.style.display = 'none';
          hangBtn.style.display = 'flex';
          pttBtn.style.display = 'flex';
          pttHint.style.display = 'block';
          pttBtn.classList.remove('active');
          callLabel.textContent = 'Colgar';
          statusText.textContent = 'Mantén el micrófono para hablar';
          statusText.className = 'status-text active';
          visualizer.classList.add('listening');
          break;
        case 'user-speaking':
          pttBtn.classList.add('active');
          statusText.textContent = 'Grabando... suelta para enviar';
          statusText.className = 'status-text speaking';
          visualizer.className = 'visualizer user-speaking';
          break;
        case 'thinking':
          pttBtn.classList.remove('active');
          pttBtn.style.display = 'none';
          pttHint.style.display = 'none';
          statusText.textContent = 'Procesando...';
          statusText.className = 'status-text waiting';
          visualizer.className = 'visualizer thinking';
          break;
        case 'ai-speaking':
          pttBtn.style.display = 'none';
          pttHint.style.display = 'none';
          statusText.textContent = 'Respondiendo...';
          statusText.className = 'status-text active';
          visualizer.className = 'visualizer ai-speaking';
          break;
      }
    }

    // --- Timer ---
    function updateTimer() {
      if (!callStartTime) return;
      const e = Math.floor((Date.now() - callStartTime) / 1000);
      timerEl.textContent = `${String(Math.floor(e / 60)).padStart(2, '0')}:${String(e % 60).padStart(2, '0')}`;
    }

    // --- Visualizer bars ---
    function visualizerTick() {
      if (!analyser || !inCall) return;
      const data = new Uint8Array(analyser.frequencyBinCount);
      function tick() {
        if (!inCall || !analyser) return;
        analyser.getByteFrequencyData(data);
        const step = Math.floor(data.length / NUM_BARS);
        for (let i = 0; i < NUM_BARS; i++) {
          let v = 0;
          for (let j = 0; j < step; j++) v += data[i * step + j];
          bars[i].style.height = Math.max(4, (v / step / 255) * 60) + 'px';
        }
        requestAnimationFrame(tick);
      }
      tick();
    }

    // --- Call control ---
    async function toggleCall() {
      await startCall();
    }

    async function startCall() {
      const cfg = getConfig();
      setUI('connecting');
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
        });
        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);

        const res = await fetch(cfg.url + '/api/v1/sessions', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + cfg.token },
          body: JSON.stringify({ instructions: cfg.instructions, voice: cfg.voice }),
        });
        const data = await res.json();
        if (!data.success) throw new Error(data.error);

        sessionId = data.session_id;
        inCall = true;
        callStartTime = Date.now();
        timerInterval = setInterval(updateTimer, 1000);
        updateTimer();
        setUI('listening');
        visualizerTick();
        addLog('Sesión iniciada ✓', 'success');
      } catch (err) {
        cleanup();
        setUI('idle');
        statusText.textContent = 'Error: ' + err.message;
        addLog('Error al conectar: ' + err.message, 'error');
      }
    }

    async function endCall() {
      if (currentAudio) { currentAudio.pause(); currentAudio = null; }
      if (sessionId) {
        const cfg = getConfig();
        try {
          await fetch(cfg.url + '/api/v1/sessions/' + sessionId, {
            method: 'DELETE',
            headers: { 'Authorization': 'Bearer ' + cfg.token },
          });
        } catch (e) { }
      }
      cleanup();
      setUI('idle');
      addLog('Sesión terminada', 'info');
    }

    function cleanup() {
      inCall = false;
      sessionId = null;
      isSpeaking = false;
      isProcessing = false;
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      if (audioContext) { audioContext.close().catch(() => { }); audioContext = null; }
      if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      mediaRecorder = null;
      analyser = null;
    }

    // --- Push-To-Talk ---
    function startPTT() {
      if (!inCall || isProcessing || isSpeaking) return;
      isSpeaking = true;
      speechStartTime = Date.now();
      startRecording();
      setUI('user-speaking');
    }

    function stopPTT() {
      if (!inCall || !isSpeaking) return;
      isSpeaking = false;
      const duration = Date.now() - (speechStartTime || 0);
      // Esperar 300ms para que los últimos chunks entren
      setTimeout(() => stopRecordingAndSend(duration), 300);
    }

    // --- Recording ---
    function startRecording() {
      if (!stream || mediaRecorder) return;
      audioChunks = [];
      try {
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
      } catch (e) {
        mediaRecorder = new MediaRecorder(stream);
      }
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) audioChunks.push(e.data); };
      mediaRecorder.start(200);
      addLog('Grabando...', 'info');
    }

    async function stopRecordingAndSend(speechDuration) {
      if (!mediaRecorder || mediaRecorder.state === 'inactive') {
        if (inCall) setUI('listening');
        return;
      }

      isProcessing = true;
      setUI('thinking');

      await new Promise(resolve => {
        mediaRecorder.onstop = resolve;
        mediaRecorder.stop();
      });
      mediaRecorder = null;

      if (speechDuration < MIN_SPEECH_MS) {
        addLog(`Audio muy corto (${speechDuration}ms), ignorado`, 'info');
        isProcessing = false;
        if (inCall) setUI('listening');
        return;
      }
      if (audioChunks.length === 0) {
        addLog('Sin datos de audio', 'error');
        isProcessing = false;
        if (inCall) setUI('listening');
        return;
      }

      const blob = new Blob(audioChunks, { type: 'audio/webm' });
      audioChunks = [];

      if (blob.size < 800) {
        addLog(`Buffer demasiado pequeño (${blob.size} bytes), ignorado`, 'info');
        isProcessing = false;
        if (inCall) setUI('listening');
        return;
      }

      addLog(`Enviando audio (${speechDuration}ms, ${blob.size} bytes)...`, 'info');

      try {
        const arrayBuffer = await blob.arrayBuffer();
        const decodeCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
        const audioBuffer = await decodeCtx.decodeAudioData(arrayBuffer);
        decodeCtx.close();
        const wavBase64 = audioBufferToWavBase64(audioBuffer);

        const cfg = getConfig();
        const res = await fetch(cfg.url + '/api/v1/sessions/' + sessionId + '/audio', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + cfg.token,
          },
          body: JSON.stringify({ audio_base64: wavBase64, audio_format: 'wav', return_audio: true }),
        });
        const data = await res.json();
        if (!data.success) throw new Error(data.error);

        if (data.input_transcript) addTranscript(data.input_transcript, 'user');
        if (data.response_text) {
          addTranscript(data.response_text, 'ai');
          addLog(`IA: ${data.response_text.substring(0, 40)}...`, 'success');
        }

        if (data.audio_wav_base64) {
          setUI('ai-speaking');
          await playAudio(data.audio_wav_base64);
        }
      } catch (err) {
        addLog(`Error: ${err.message}`, 'error');
      }

      isProcessing = false;
      if (inCall) setUI('listening');
    }

    // --- Audio playback ---
    function playAudio(wavBase64) {
      return new Promise(resolve => {
        currentAudio = new Audio('data:audio/wav;base64,' + wavBase64);
        currentAudio.onended = () => { currentAudio = null; resolve(); };
        currentAudio.onerror = () => { currentAudio = null; resolve(); };
        currentAudio.play().catch(() => { currentAudio = null; resolve(); });
      });
    }

    // --- Transcript ---
    function addTranscript(text, role) {
      const p = document.createElement('p');
      p.className = role === 'user' ? 'user-text' : 'ai-text';
      p.textContent = text;
      transcriptEl.appendChild(p);
      transcriptEl.scrollTop = transcriptEl.scrollHeight;
    }

    // --- WAV encoder (PCM16 mono 24kHz) ---
    function audioBufferToWavBase64(buffer) {
      const SR = 24000;
      const input = buffer.getChannelData(0);
      const ratio = buffer.sampleRate / SR;
      const outLen = Math.floor(input.length / ratio);
      const pcm = new Int16Array(outLen);
      for (let i = 0; i < outLen; i++) {
        const si = i * ratio;
        const sf = Math.floor(si);
        const f = si - sf;
        const s = (input[sf] || 0) + ((input[sf + 1] || 0) - (input[sf] || 0)) * f;
        const c = Math.max(-1, Math.min(1, s));
        pcm[i] = c < 0 ? c * 0x8000 : c * 0x7FFF;
      }
      const dataSize = pcm.length * 2;
      const wav = new ArrayBuffer(44 + dataSize);
      const v = new DataView(wav);
      const w = (o, s) => { for (let i = 0; i < s.length; i++) v.setUint8(o + i, s.charCodeAt(i)); };
      w(0, 'RIFF'); v.setUint32(4, 36 + dataSize, true);
      w(8, 'WAVE'); w(12, 'fmt ');
      v.setUint32(16, 16, true); v.setUint16(20, 1, true); v.setUint16(22, 1, true);
      v.setUint32(24, SR, true); v.setUint32(28, SR * 2, true);
      v.setUint16(32, 2, true); v.setUint16(34, 16, true);
      w(36, 'data'); v.setUint32(40, dataSize, true);
      new Uint8Array(wav, 44).set(new Uint8Array(pcm.buffer));
      let bin = ''; const bytes = new Uint8Array(wav);
      for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
      return btoa(bin);
    }
  </script>
</body>

</html>